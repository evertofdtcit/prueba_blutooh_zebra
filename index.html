<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>üî¨ Investigaci√≥n Zebra ZD421</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            margin: 0;
            padding: 15px;
            background: #f5f5f5;
            font-size: 16px;
        }
        .container {
            background: white;
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
        }
        h1, h2, h3 {
            color: #333;
            text-align: center;
        }
        .status {
            padding: 15px;
            margin: 10px 0;
            border-radius: 5px;
            font-weight: bold;
            text-align: center;
        }
        .success { background: #d4edda; color: #155724; }
        .error { background: #f8d7da; color: #721c24; }
        .warning { background: #fff3cd; color: #856404; }
        .info { background: #d1ecf1; color: #0c5460; }
        
        button {
            width: 100%;
            background: #007bff;
            color: white;
            border: none;
            padding: 15px;
            margin: 8px 0;
            border-radius: 5px;
            font-size: 16px;
            cursor: pointer;
        }
        button:hover { background: #0056b3; }
        button:disabled { background: #6c757d; cursor: not-allowed; }
        
        .log {
            background: #f8f9fa;
            border: 1px solid #dee2e6;
            padding: 15px;
            margin: 15px 0;
            border-radius: 5px;
            height: 400px;
            overflow-y: auto;
            font-family: monospace;
            font-size: 12px;
            white-space: pre-wrap;
        }
        
        .step {
            margin: 20px 0;
            padding: 15px;
            border: 2px solid #007bff;
            border-radius: 5px;
            background: #f8f9ff;
        }
        
        .step h3 {
            margin-top: 0;
            color: #007bff;
        }
        
        .service-list {
            background: #e9ecef;
            padding: 10px;
            margin: 10px 0;
            border-radius: 5px;
            font-family: monospace;
            font-size: 12px;
            max-height: 200px;
            overflow-y: auto;
        }
        
        .uuid-result {
            background: #fff3cd;
            border: 1px solid #ffeaa7;
            padding: 10px;
            margin: 5px 0;
            border-radius: 3px;
            font-family: monospace;
            font-size: 11px;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>üî¨ Investigaci√≥n Profunda Zebra ZD421</h1>
        <p style="text-align: center; color: #666;">Encontrando el servicio correcto para impresi√≥n</p>
        
        <div id="bluetoothStatus" class="status info">
            ‚ÑπÔ∏è Listo para investigar
        </div>
        
        <div class="step">
            <h3>üïµÔ∏è PASO 1: Exploraci√≥n Completa</h3>
            <button onclick="step1_fullExploration()">üîç Explorar TODOS los Servicios y UUIDs</button>
            <p><strong>Objetivo:</strong> Mapear absolutamente todo lo que tiene disponible tu Zebra</p>
        </div>
        
        <div class="step">
            <h3>üéØ PASO 2: Servicios de Impresi√≥n</h3>
            <button onclick="step2_findPrintServices()">üñ®Ô∏è Buscar Servicios de Impresi√≥n Espec√≠ficos</button>
            <p><strong>Objetivo:</strong> Probar UUIDs conocidos de impresoras Zebra</p>
        </div>
        
        <div class="step">
            <h3>üì° PASO 3: Emparejamiento Avanzado</h3>
            <button onclick="step3_advancedPairing()">üîó Verificar Emparejamiento y Autenticaci√≥n</button>
            <p><strong>Objetivo:</strong> Asegurar que el dispositivo est√© completamente autorizado</p>
        </div>
        
        <div class="step">
            <h3>üß™ PASO 4: Protocolos Alternativos</h3>
            <button onclick="step4_alternativeProtocols()">üìã Probar Comandos No-ZPL</button>
            <p><strong>Objetivo:</strong> ESC/POS, Raw, configuraci√≥n previa</p>
        </div>
        
        <div class="step">
            <h3>‚öôÔ∏è PASO 5: Configuraci√≥n Zebra</h3>
            <button onclick="step5_zebraConfig()">üîß Comandos de Configuraci√≥n Zebra</button>
            <p><strong>Objetivo:</strong> Activar modo Web Bluetooth si existe</p>
        </div>
        
        <div class="step">
            <h3>üìã Log de Investigaci√≥n</h3>
            <button onclick="clearLog()">üóëÔ∏è Limpiar Log</button>
            <div id="log" class="log">Investigaci√≥n iniciada...\n</div>
        </div>
        
        <div id="results" class="service-list" style="display: none;"></div>
    </div>

    <script>
        let device = null;
        let server = null;
        let discoveredServices = [];
        
        // UUIDs conocidos de impresoras
        const KNOWN_PRINTER_UUIDS = {
            // Serial Port Profile
            serialPort: '00001101-0000-1000-8000-00805f9b34fb',
            
            // Zebra espec√≠ficos
            zebraService1: '00001801-0000-1000-8000-00805f9b34fb',
            zebraService2: '0000180a-0000-1000-8000-00805f9b34fb',
            zebraService3: '00001800-0000-1000-8000-00805f9b34fb',
            
            // Impresoras comunes
            printerService: '49535343-fe7d-4ae5-8fa9-9fafd205e455',
            printerTx: '49535343-1e4d-4bd9-ba61-23c647249616',
            printerRx: '49535343-8841-43f4-a8d4-ecbe34729bb3',
            
            // Nordic UART Service (com√∫n en impresoras)
            nordicUart: '6e400001-b5a3-f393-e0a9-e50e24dcca9e',
            nordicTx: '6e400002-b5a3-f393-e0a9-e50e24dcca9e',
            nordicRx: '6e400003-b5a3-f393-e0a9-e50e24dcca9e',
            
            // Otros servicios de comunicaci√≥n
            customService1: '0000fff0-0000-1000-8000-00805f9b34fb',
            customService2: '0000ffe0-0000-1000-8000-00805f9b34fb'
        };
        
        function log(message) {
            const logEl = document.getElementById('log');
            const timestamp = new Date().toLocaleTimeString();
            logEl.textContent += `[${timestamp}] ${message}\n`;
            logEl.scrollTop = logEl.scrollHeight;
            console.log(message);
        }
        
        function updateStatus(message, type = 'info') {
            const statusEl = document.getElementById('bluetoothStatus');
            statusEl.className = `status ${type}`;
            
            const icons = {
                success: '‚úÖ',
                error: '‚ùå',
                warning: '‚ö†Ô∏è',
                info: '‚ÑπÔ∏è'
            };
            
            statusEl.textContent = `${icons[type]} ${message}`;
        }
        
        function clearLog() {
            document.getElementById('log').textContent = 'Log limpio...\n';
        }
        
        async function connectToDevice() {
            try {
                if (device && device.gatt.connected) {
                    return true;
                }
                
                log('üîç Conectando a Zebra ZD421...');
                updateStatus('Conectando...', 'info');
                
                device = await navigator.bluetooth.requestDevice({
                    filters: [{ name: 'D6N250950239' }],
                    optionalServices: [
                        ...Object.values(KNOWN_PRINTER_UUIDS),
                        // Agregar algunos UUIDs gen√©ricos m√°s
                        '0000180f-0000-1000-8000-00805f9b34fb', // Battery
                        '0000181a-0000-1000-8000-00805f9b34fb', // Environmental Sensing
                        '12345678-1234-5678-9abc-123456789abc'  // Custom UUID ejemplo
                    ]
                });
                
                server = await device.gatt.connect();
                log('‚úÖ Conectado al servidor GATT');
                updateStatus('Conectado - Listo para investigar', 'success');
                
                return true;
                
            } catch (error) {
                log(`‚ùå Error conectando: ${error.message}`);
                updateStatus('Error de conexi√≥n', 'error');
                return false;
            }
        }
        
        // PASO 1: Exploraci√≥n completa
        async function step1_fullExploration() {
            if (!await connectToDevice()) return;
            
            log('\nüïµÔ∏è PASO 1: EXPLORACI√ìN COMPLETA DE SERVICIOS');
            log('=' .repeat(50));
            
            try {
                const services = await server.getPrimaryServices();
                log(`üìã TOTAL DE SERVICIOS ENCONTRADOS: ${services.length}`);
                
                discoveredServices = [];
                
                for (let i = 0; i < services.length; i++) {
                    const service = services[i];
                    log(`\nüîπ SERVICIO ${i + 1}/${services.length}:`);
                    log(`   UUID: ${service.uuid}`);
                    log(`   Instancia: ${service.instanceId || 'N/A'}`);
                    
                    const serviceData = {
                        uuid: service.uuid,
                        characteristics: []
                    };
                    
                    try {
                        const characteristics = await service.getCharacteristics();
                        log(`   üìù Caracter√≠sticas: ${characteristics.length}`);
                        
                        for (let j = 0; j < characteristics.length; j++) {
                            const char = characteristics[j];
                            
                            const properties = [];
                            if (char.properties.read) properties.push('READ');
                            if (char.properties.write) properties.push('WRITE');
                            if (char.properties.writeWithoutResponse) properties.push('WRITE_NO_RESP');
                            if (char.properties.notify) properties.push('NOTIFY');
                            if (char.properties.indicate) properties.push('INDICATE');
                            if (char.properties.broadcast) properties.push('BROADCAST');
                            if (char.properties.authenticatedSignedWrites) properties.push('AUTH_WRITE');
                            
                            log(`     üìå Caracter√≠stica ${j + 1}: ${char.uuid}`);
                            log(`        Propiedades: [${properties.join(', ')}]`);
                            
                            serviceData.characteristics.push({
                                uuid: char.uuid,
                                properties: char.properties,
                                characteristic: char
                            });
                            
                            // Si tiene READ, intentar leer valor
                            if (char.properties.read) {
                                try {
                                    const value = await char.readValue();
                                    const decoder = new TextDecoder();
                                    const textValue = decoder.decode(value);
                                    log(`        Valor actual: "${textValue}" (${value.byteLength} bytes)`);
                                } catch (readError) {
                                    log(`        Valor: No se puede leer (${readError.message})`);
                                }
                            }
                        }
                        
                    } catch (charError) {
                        log(`   ‚ùå Error obteniendo caracter√≠sticas: ${charError.message}`);
                    }
                    
                    discoveredServices.push(serviceData);
                }
                
                log('\nüéØ RESUMEN DE SERVICIOS CON CAPACIDAD DE ESCRITURA:');
                log('-' .repeat(50));
                
                let writeableCount = 0;
                for (const service of discoveredServices) {
                    for (const char of service.characteristics) {
                        if (char.properties.write || char.properties.writeWithoutResponse) {
                            writeableCount++;
                            log(`‚úçÔ∏è ${service.uuid} ‚Üí ${char.uuid}`);
                            log(`   [${char.properties.write ? 'WRITE' : ''}${char.properties.write && char.properties.writeWithoutResponse ? ', ' : ''}${char.properties.writeWithoutResponse ? 'WRITE_NO_RESP' : ''}]`);
                        }
                    }
                }
                
                log(`\nüìä TOTAL CARACTER√çSTICAS ESCRIBIBLES: ${writeableCount}`);
                updateStatus(`Exploraci√≥n completa: ${services.length} servicios, ${writeableCount} escribibles`, 'success');
                
            } catch (error) {
                log(`‚ùå Error en exploraci√≥n: ${error.message}`);
                updateStatus('Error en exploraci√≥n', 'error');
            }
        }
        
        // PASO 2: Buscar servicios de impresi√≥n espec√≠ficos
        async function step2_findPrintServices() {
            if (!await connectToDevice()) return;
            
            log('\nüñ®Ô∏è PASO 2: BUSCANDO SERVICIOS DE IMPRESI√ìN ESPEC√çFICOS');
            log('=' .repeat(50));
            
            for (const [name, uuid] of Object.entries(KNOWN_PRINTER_UUIDS)) {
                log(`\nüîç Probando ${name}: ${uuid}`);
                
                try {
                    const service = await server.getPrimaryService(uuid);
                    log(`   ‚úÖ ¬°SERVICIO ENCONTRADO!`);
                    
                    try {
                        const characteristics = await service.getCharacteristics();
                        log(`   üìù Caracter√≠sticas: ${characteristics.length}`);
                        
                        for (const char of characteristics) {
                            const props = [];
                            if (char.properties.read) props.push('READ');
                            if (char.properties.write) props.push('write');
                            if (char.properties.writeWithoutResponse) props.push('writeNoResp');
                            if (char.properties.notify) props.push('notify');
                            
                            log(`      üìå ${char.uuid} [${props.join(', ')}]`);
                            
                            // Si es escribible, probar con comando simple
                            if (char.properties.write || char.properties.writeWithoutResponse) {
                                log(`      üß™ Probando escritura simple...`);
                                
                                try {
                                    const testData = new TextEncoder().encode('TEST');
                                    
                                    if (char.properties.writeWithoutResponse) {
                                        await char.writeValueWithoutResponse(testData);
                                        log(`      ‚úÖ writeValueWithoutResponse FUNCION√ì!`);
                                    } else {
                                        await char.writeValue(testData);
                                        log(`      ‚úÖ writeValue FUNCION√ì!`);
                                    }
                                    
                                    log(`      üéâ ¬°POSIBLE SERVICIO DE IMPRESI√ìN ENCONTRADO!`);
                                    updateStatus(`Servicio de impresi√≥n encontrado: ${name}`, 'success');
                                    
                                } catch (writeError) {
                                    log(`      ‚ùå Error escribiendo: ${writeError.message}`);
                                }
                            }
                        }
                        
                    } catch (charError) {
                        log(`   ‚ùå Error caracter√≠sticas: ${charError.message}`);
                    }
                    
                } catch (serviceError) {
                    log(`   ‚ùå Servicio no disponible`);
                }
            }
        }
        
        // PASO 3: Emparejamiento avanzado
        async function step3_advancedPairing() {
            log('\nüîó PASO 3: VERIFICACI√ìN DE EMPAREJAMIENTO');
            log('=' .repeat(50));
            
            if (!device) {
                log('‚ùå No hay dispositivo conectado');
                return;
            }
            
            log(`üì± Dispositivo: ${device.name}`);
            log(`üÜî ID: ${device.id}`);
            log(`üîó Conectado: ${device.gatt.connected}`);
            
            // Verificar si est√° emparejado en el sistema
            if ('bluetooth' in navigator && 'getDevices' in navigator.bluetooth) {
                try {
                    const devices = await navigator.bluetooth.getDevices();
                    log(`üìã Dispositivos emparejados: ${devices.length}`);
                    
                    const pairedDevice = devices.find(d => d.id === device.id);
                    if (pairedDevice) {
                        log(`‚úÖ Dispositivo est√° emparejado en el sistema`);
                    } else {
                        log(`‚ö†Ô∏è Dispositivo NO est√° emparejado en el sistema`);
                        log(`üí° Recomendaci√≥n: Emparejar manualmente en configuraci√≥n Bluetooth`);
                    }
                    
                } catch (error) {
                    log(`‚ùå Error verificando emparejamiento: ${error.message}`);
                }
            }
            
            // Informaci√≥n del GATT server
            log(`\nüîß Informaci√≥n GATT:`);
            log(`   Estado: ${server ? 'Disponible' : 'No disponible'}`);
            
            if (server) {
                log(`   Conectado: ${server.connected}`);
            }
        }
        
        // PASO 4: Protocolos alternativos
        async function step4_alternativeProtocols() {
            if (!await connectToDevice()) return;
            
            log('\nüìã PASO 4: PROBANDO PROTOCOLOS ALTERNATIVOS');
            log('=' .repeat(50));
            
            // Buscar caracter√≠sticas escribibles
            const writeableChars = [];
            
            if (discoveredServices.length === 0) {
                log('‚ö†Ô∏è Ejecuta primero PASO 1 para explorar servicios');
                return;
            }
            
            for (const service of discoveredServices) {
                for (const char of service.characteristics) {
                    if (char.properties.write || char.properties.writeWithoutResponse) {
                        writeableChars.push(char);
                    }
                }
            }
            
            if (writeableChars.length === 0) {
                log('‚ùå No hay caracter√≠sticas escribibles disponibles');
                return;
            }
            
            const protocols = [
                { name: 'Texto Simple', data: 'Hello' },
                { name: 'ESC/POS Reset', data: '\x1B\x40' },
                { name: 'ESC/POS Print', data: '\x1B\x40Hello\x0A\x0A\x0A\x1D\x56\x41\x10' },
                { name: 'ZPL M√≠nimo', data: '^XA^FDTest^FS^XZ' },
                { name: 'Comando Raw', data: 'PRINT "Hello"' },
                { name: 'Bytes Simples', data: '\x02\x48\x65\x6C\x6C\x6F\x03' }
            ];
            
            for (const protocol of protocols) {
                log(`\nüß™ Probando: ${protocol.name}`);
                
                for (const char of writeableChars) {
                    log(`   üìù En caracter√≠stica: ${char.uuid}`);
                    
                    try {
                        const data = new TextEncoder().encode(protocol.data);
                        
                        if (char.properties.writeWithoutResponse) {
                            await char.characteristic.writeValueWithoutResponse(data);
                            log(`   ‚úÖ writeValueWithoutResponse exitoso`);
                        } else {
                            await char.characteristic.writeValue(data);
                            log(`   ‚úÖ writeValue exitoso`);
                        }
                        
                        log(`   üéâ ¬°${protocol.name} FUNCION√ì!`);
                        updateStatus(`Protocolo funcionando: ${protocol.name}`, 'success');
                        
                        // Pausa para ver si imprime
                        await new Promise(resolve => setTimeout(resolve, 2000));
                        
                    } catch (error) {
                        log(`   ‚ùå Error: ${error.message}`);
                    }
                }
            }
        }
        
        // PASO 5: Configuraci√≥n Zebra
        async function step5_zebraConfig() {
            if (!await connectToDevice()) return;
            
            log('\nüîß PASO 5: COMANDOS DE CONFIGURACI√ìN ZEBRA');
            log('=' .repeat(50));
            
            const configCommands = [
                { name: 'Host Status', cmd: '~HS' },
                { name: 'Host Identification', cmd: '~HI' },
                { name: 'Configuration Status', cmd: '^XA^HH^XZ' },
                { name: 'Print Configuration', cmd: '~WC' },
                { name: 'Head Test Fatal', cmd: '~JT' },
                { name: 'Cancel All', cmd: '~JA' }
            ];
            
            // Buscar caracter√≠sticas escribibles conocidas
            const zebraChar = discoveredServices
                .find(s => s.uuid === '00001801-0000-1000-8000-00805f9b34fb')
                ?.characteristics
                .find(c => c.uuid === '00002b29-0000-1000-8000-00805f9b34fb');
            
            if (!zebraChar) {
                log('‚ùå No se encontr√≥ la caracter√≠stica Zebra conocida');
                return;
            }
            
            for (const config of configCommands) {
                log(`\n‚öôÔ∏è Enviando: ${config.name} (${config.cmd})`);
                
                try {
                    const data = new TextEncoder().encode(config.cmd);
                    
                    if (zebraChar.properties.writeWithoutResponse) {
                        await zebraChar.characteristic.writeValueWithoutResponse(data);
                    } else {
                        await zebraChar.characteristic.writeValue(data);
                    }
                    
                    log(`   ‚úÖ Comando enviado exitosamente`);
                    
                    // Pausa entre comandos
                    await new Promise(resolve => setTimeout(resolve, 1000));
                    
                } catch (error) {
                    log(`   ‚ùå Error: ${error.message}`);
                }
            }
        }
        
        // Auto-verificar Bluetooth al cargar
        window.onload = function() {
            if ('bluetooth' in navigator) {
                log('‚úÖ Web Bluetooth API disponible');
                updateStatus('Listo para investigaci√≥n profunda', 'success');
            } else {
                log('‚ùå Web Bluetooth API no disponible');
                updateStatus('Web Bluetooth no soportado', 'error');
            }
        };
    </script>
</body>
</html>
